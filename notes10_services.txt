------------------------------------------------------------------------------
LESSON 10 - Services
------------------------------------------------------------------------------

Activity
Content Provider
Service
Broadcast Receiver


Services vs Loaders
-------------------

LOADER:
 
 - Loaders are tied to the Activity lifecycle
 - Easier to make UI changes and communicate with activity
 - Good candidates are:
   - Query DB to populate RecyclerViewAdapter
   - Decode an image to populate an ImageView
 
SERVICE:

 - Decoupled from the UI
 - Exists when there is no UI
 - Good candidates are:
   - Updating a DB in the background
	 
Starting Services
-----------------

 - Start (a service manually)
 - Schedule (a service)
 - Bind (to a service)
 
START SERVICE:

 - Context.startService(); // Or Activity
 - Service starts but does not interact with the activity again (fire and forget)
 - These are called started services

SCHEDULE SERVICE:

 - JobService
 - JobScheduler (Or FirebaseJobDispatcher)
 - Allow for complex schedules (like run every 24h while on wifi)
 
BOUND SERVICES:

                       --------------
 Service as a          |   Service  |
 "Server"              --------------
                            |  A
                            |  |
                            |  |
                            V  |
                       --------------
 Component as a        |  Activity  |------> bindService()
 "client"              --------------
 
 - These are called bound services
 - Component binds to service
 - Client server model
 - Allows for 2way comunication
 - A service can be both bound and started
 - https://developer.android.com/guide/components/bound-services.html

---------------- 
STARTED SERVICES
----------------

   -----------------------------------------------------------------
   |  All Android core components (activities, content providers,  |
   | services and broadcast receivers) start on the main thread!!! |
   -----------------------------------------------------------------

BASE SERVICE CLASS
------------------
   
 - The base abstract Service class runs in the main thread
 - Need to create a background task or AsynchTask from within the service
 
Started Service Liffecycle:

  - Call to startService()
  
  - Triggers Service.onCreate()
  
  - Service.onStartCommand() is called
  
  - Should span a thread (AsynchTask) and do the long running work in onStartCommand ...
  
  - SERVICE IS RUNNING
  
  - Call stopSelf() when done (service is stopped by itself or a client)
  
  - Triggers Service.onDestroy()
  
  - SERVICE IS DESTROYED

INTENT SERVICE
--------------

 - Runs on its own thread, no new to start one owerselves
 - Extend IntentService and overide onHandleIntent()
 - Started simmilarly to an activity
 
	Intent intent = new Intent(this,MyActivity.class);
	startActivity(intent);
	
	Intent intent = new Intent(this,MyIntentService.class);
	startService(intent);
	
 - Can pass info in
 
	public class MyIntentService extends IntentService {
		@Override
		protected void onHandleIntent(Intent intent) {
			// Do background work here ...
		}
	}
	Intent intent = new Intent(this,MyIntentService.class);
	intent.setAction("My action ...");
	startService(intent);
 
 - All Intent services run onHandleIntent in a backgroud thread, but they all run it on the same backgound thread!
 - They run in order ... good for activities that need to occur in sequence ...
 

REGISTER IN ANDROID MANIFEST
----------------------------

	<?xml version="1.0" encoding="utf-8"?>
	<manifest xmlns:android="http://schemas.android.com/apk/res/android"
			  package="com.example.android.background">
		<application
			android:allowBackup="true"
			android:icon="@mipmap/ic_launcher"
			android:label="@string/app_name"
			android:supportsRtl="true"
			android:theme="@style/AppTheme">
			<!-- ... -->
			<service
				android:name=".sync.WaterReminderIntentService"
				android:exported="false" />
		</application>
	</manifest>
 
-------------
NOTIFICATIONS
-------------

	https://developer.android.com/guide/topics/ui/notifiers/notifications.html
	https://material.io/guidelines/patterns/notifications.html

 - JELLYBEAD: Actions
 - LOLIPOP: New template types + heads up notifications + android wear
 - NOUGAT: changes layout to allways specify the app sending the notification, allows for inline replies and adds the ablity to specify custom layouts for headsup and custom notifications
 
 - Notifications on Android are displayed by a system service called NotificationManager
 - System services are separate processes that are started by the Android system itself

 
PENDING INTENTS
---------------

	https://developer.android.com/reference/android/app/PendingIntent.html

 - Regular intents allow an app to launch activities within the same app of from other apps, either explicitly or implicitly
 - Launching other apps or services from another app, requires the manifest to include the appropriate permissions
 - Pending intent is a wrapper arrount an intent that is designed to be used by another application
 - It gives the other application the ability to perform the included action as is it were the application that gemerated 
  the pending intent, with all the permissions the later has been granted
    - It can launch services, private activities and broadcast protected intents
	- Even if the target application is no longer running
 - Usefull to start activities from notifications
 
 - Create with:
	PendingIntent.getActivity(Context context, int requestCode, Intent intent, int flags)
		- Context in which the pending intent shoud start the activity
		- requestCode private requestCode for the sender, make sure it is unique per pending intent
		- Intent to run in our app 
		- flags - what to do when we have several pending intents for the same intent ... update or cancel current ...
	PendingIntent.getService()
	PendingIntent.getBroadcast()
	
NOTIFICATIONS
-------------

	https://developer.android.com/training/notify-user/build-notification.html
	https://developer.android.com/training/notify-user/expanded.html
	https://developer.android.com/reference/android/app/Notification.BigPictureStyle.html
 
    <uses-permission android:name="android.permission.VIBRATE"/>

	public class NotificationUtils {
		private static final int WATER_REMINDER_PENDING_INTENT_ID = 123;
		private static final int WATER_REMINDER_NOTIFICATION_ID = 33423;
		// https://developer.android.com/training/notify-user/build-notification.html
		public void remindUserBecauseCharging(Context context) {
			NotificationCompat.Builder builder = new NotificationCompat.Builder(context)
					.setColor(ContextCompat.getColor(context,R.color.colorPrimary))
					.setSmallIcon(R.drawable.ic_drink_notification)
					.setLargeIcon(largeIcon(context))
					.setContentTitle(context.getString(R.string.charging_reminder_notification_title))
					.setContentText(context.getString(R.string.charging_reminder_notification_body))
					.setStyle(new NotificationCompat.BigTextStyle().bigText(context.getString(R.string.charging_reminder_notification_body)))
					.setDefaults(Notification.DEFAULT_VIBRATE)
					.setContentIntent(contentIntent(context))
					.setAutoCancel(true);   // auto cancel - Cancels the notification when the users clicks on it
			NotificationManager notificationManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
			notificationManager.notify(WATER_REMINDER_PENDING_INTENT_ID,builder.build());
		}
		private PendingIntent contentIntent(Context context) {
			Intent intent = new Intent(context, MainActivity.class);
			return PendingIntent.getActivity(context,WATER_REMINDER_NOTIFICATION_ID,intent,PendingIntent.FLAG_UPDATE_CURRENT);
		}
		private static Bitmap largeIcon(Context context) {
			return BitmapFactory.decodeResource(context.getResources(), R.drawable.ic_local_drink_black_24px);
		}
	}




 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
-------------------------
SIDE NOTE - PLURALIZATION
-------------------------

	https://developer.android.com/guide/topics/resources/string-resource.html#Plurals

	
Pluralization in Android

Part of Android’s robust resource framework involves a mechanism for pluralizing strings called “Quantity Strings”. In the strings.xml file for the Hydration Reminder app, you’ll see an example of how pluralization can be used:

<plurals name="charge_notification_count">
   <item quantity="zero">Hydrate while charging reminder sent %d times</item>
   <item quantity="one">Hydrate while charging reminder sent %d time</item>
   <item quantity="other">Hydrate while charging reminder sent %d times</item>
</plurals>
When you use the plural in code, you specify a quantity number. This number specifies what string should be used. In this case:

if the number is zero, use <item quantity="zero">
If the number is one, use <item quantity="one">
otherwise use <item quantity="other">
Then in the MainActivity we have the following Java code to generate the correct String:

String formattedChargingReminders = getResources().getQuantityString(R.plurals.charge_notification_count, chargingReminders, chargingReminders);
The first usage of chargingReminder is the quantity number. It determines which version of the pluralized string to use (you must pass in a number). The second usage of chargingReminder is the number that’s actually inserted into the formatted string.

